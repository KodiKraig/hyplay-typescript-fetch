/* tslint:disable */
/* eslint-disable */
/**
 * HYPLAY API
 * HYPLAY API Specification
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: braydon@hytopia.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ContractModel,
  CreateContractRequest,
  CreateTemplateRequest,
  ReadContractArgsParameterInner,
  TemplateModel,
  UpdateContractRequest,
} from '../models/index';
import {
    ContractModelFromJSON,
    ContractModelToJSON,
    CreateContractRequestFromJSON,
    CreateContractRequestToJSON,
    CreateTemplateRequestFromJSON,
    CreateTemplateRequestToJSON,
    ReadContractArgsParameterInnerFromJSON,
    ReadContractArgsParameterInnerToJSON,
    TemplateModelFromJSON,
    TemplateModelToJSON,
    UpdateContractRequestFromJSON,
    UpdateContractRequestToJSON,
} from '../models/index';

export interface CreateContractOperationRequest {
    createContractRequest: CreateContractRequest;
    xAppAuthorization?: string;
    xAuthorization?: string;
}

export interface CreateTemplateOperationRequest {
    xAuthorization: string;
    createTemplateRequest: CreateTemplateRequest;
}

export interface GetContractRequest {
    contractId: string;
}

export interface GetOwnedContractsRequest {
    xAuthorization: string;
}

export interface GetTemplateRequest {
    templateId: string;
}

export interface GetTemplatesRequest {
    userId?: string;
    name?: string;
    approved?: string;
}

export interface ReadContractRequest {
    contractIdOrAddress: string;
    func: string;
    xAppAuthorization?: string;
    xSessionAuthorization?: string;
    xAuthorization?: string;
    chain?: ReadContractChainEnum;
    args?: Array<ReadContractArgsParameterInner>;
    as?: string;
}

export interface UpdateContractOperationRequest {
    xAuthorization: string;
    contractId: string;
    updateContractRequest: UpdateContractRequest;
}

/**
 * ContractsApi - interface
 * 
 * @export
 * @interface ContractsApiInterface
 */
export interface ContractsApiInterface {
    /**
     * Deploy a new contract from a template, or import an already deployed contract. Deploying or importing a contract through this endpoint will create a new contract object within the HYPLAY system. Once created, you can then programmatically interact with the contract gaslessly as a user, app or through a user\'s session. Use HYPLAY\'s create transaction and read contract endpoints for interactions.
     * @summary Create contract
     * @param {CreateContractRequest} createContractRequest 
     * @param {string} [xAppAuthorization] The &#x60;secretKey&#x60; or &#x60;testSecretKey&#x60; of the authenticating app.
     * @param {string} [xAuthorization] The &#x60;accessToken&#x60; of the authenticating user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApiInterface
     */
    createContractRaw(requestParameters: CreateContractOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContractModel>>;

    /**
     * Deploy a new contract from a template, or import an already deployed contract. Deploying or importing a contract through this endpoint will create a new contract object within the HYPLAY system. Once created, you can then programmatically interact with the contract gaslessly as a user, app or through a user\'s session. Use HYPLAY\'s create transaction and read contract endpoints for interactions.
     * Create contract
     */
    createContract(requestParameters: CreateContractOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContractModel>;

    /**
     * Creates a new template. Templates can be used to quickly deploy pre-approved types of contracts to HYCHAIN and HYCHAIN_TESTNET.
     * @summary Create template
     * @param {string} xAuthorization The &#x60;accessToken&#x60; of the authenticating user.
     * @param {CreateTemplateRequest} createTemplateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApiInterface
     */
    createTemplateRaw(requestParameters: CreateTemplateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TemplateModel>>;

    /**
     * Creates a new template. Templates can be used to quickly deploy pre-approved types of contracts to HYCHAIN and HYCHAIN_TESTNET.
     * Create template
     */
    createTemplate(requestParameters: CreateTemplateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TemplateModel>;

    /**
     * Returns a contract object for the provided contractId.
     * @summary Get contract
     * @param {string} contractId A contract id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApiInterface
     */
    getContractRaw(requestParameters: GetContractRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContractModel>>;

    /**
     * Returns a contract object for the provided contractId.
     * Get contract
     */
    getContract(requestParameters: GetContractRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContractModel>;

    /**
     * Returned an array of contracts owned by the authorized user.
     * @summary Get owned contracts
     * @param {string} xAuthorization The &#x60;accessToken&#x60; of the authenticating user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApiInterface
     */
    getOwnedContractsRaw(requestParameters: GetOwnedContractsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ContractModel>>>;

    /**
     * Returned an array of contracts owned by the authorized user.
     * Get owned contracts
     */
    getOwnedContracts(requestParameters: GetOwnedContractsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ContractModel>>;

    /**
     * Returns a template object with abi, bytecode and compilation errors or warnings included.
     * @summary Get template
     * @param {string} templateId A template id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApiInterface
     */
    getTemplateRaw(requestParameters: GetTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TemplateModel>>;

    /**
     * Returns a template object with abi, bytecode and compilation errors or warnings included.
     * Get template
     */
    getTemplate(requestParameters: GetTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TemplateModel>;

    /**
     * Returns an array of templates. Templates can be used to quickly deploy contracts to HYCHAIN and HYCHAIN_TESTNET. Templates can also be reviewed and approved by the HYPLAY team to be made available for anyone to deploy. Templates that are not approved can be deployed by anyone to HYCHAIN_TESTNET, and only deployed by the creator to HYCHAIN mainnet.
     * @summary Get templates
     * @param {string} [userId] A user id.
     * @param {string} [name] A template name to partially or exactly match.
     * @param {string} [approved] Set this query parameter to &#x60;true&#x60; to filter for approved templates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApiInterface
     */
    getTemplatesRaw(requestParameters: GetTemplatesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<TemplateModel>>>;

    /**
     * Returns an array of templates. Templates can be used to quickly deploy contracts to HYCHAIN and HYCHAIN_TESTNET. Templates can also be reviewed and approved by the HYPLAY team to be made available for anyone to deploy. Templates that are not approved can be deployed by anyone to HYCHAIN_TESTNET, and only deployed by the creator to HYCHAIN mainnet.
     * Get templates
     */
    getTemplates(requestParameters: GetTemplatesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<TemplateModel>>;

    /**
     * Get the value from a read function of a target contract. This endpoint is designed to be highly flexible. It can read any contract by providing a contract address for `contractIdOrAddress`. It can also read using contracts created in the HYCHAIN systems through the `POST /v1/contracts` endpoint, which will utilize the contract\'s ABI.  Additionally, reads can be performed as a HYCHAIN app, user or user\'s session provided, through header authorization, or any arbitrary address or walletId provided through the `as` query parameter. Alternatively you can omit all of this and perform a read as no specific address.  The `func` query parameter accepts a complete function signature with parameters, such as `getCount()` or `readCounter(address,uint256)`, or a known function name without parameters if a contractId was provided for `contractIdOrAddress` and the contract\'s ABI is known. Such as `readCounter`.
     * @summary Read contract
     * @param {string} contractIdOrAddress A contract id or address.
     * @param {string} func A function name or function signature.
     * @param {string} [xAppAuthorization] The &#x60;secretKey&#x60; or &#x60;testSecretKey&#x60; of the authenticating app.
     * @param {string} [xSessionAuthorization] The &#x60;accessToken&#x60; of the authenticating session.
     * @param {string} [xAuthorization] The &#x60;accessToken&#x60; of the authenticating user.
     * @param {'HYCHAIN' | 'HYCHAIN_TESTNET' | 'LOCAL'} [chain] A chain name.
     * @param {Array<ReadContractArgsParameterInner>} [args] An array of arguments.
     * @param {string} [as] An address or walletId to perform as.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApiInterface
     */
    readContractRaw(requestParameters: ReadContractRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>>;

    /**
     * Get the value from a read function of a target contract. This endpoint is designed to be highly flexible. It can read any contract by providing a contract address for `contractIdOrAddress`. It can also read using contracts created in the HYCHAIN systems through the `POST /v1/contracts` endpoint, which will utilize the contract\'s ABI.  Additionally, reads can be performed as a HYCHAIN app, user or user\'s session provided, through header authorization, or any arbitrary address or walletId provided through the `as` query parameter. Alternatively you can omit all of this and perform a read as no specific address.  The `func` query parameter accepts a complete function signature with parameters, such as `getCount()` or `readCounter(address,uint256)`, or a known function name without parameters if a contractId was provided for `contractIdOrAddress` and the contract\'s ABI is known. Such as `readCounter`.
     * Read contract
     */
    readContract(requestParameters: ReadContractRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string>;

    /**
     * Updates a contract owned by the authorized user for the provided contractId.
     * @summary Update contract
     * @param {string} xAuthorization The &#x60;accessToken&#x60; of the authenticating user.
     * @param {string} contractId A contract id.
     * @param {UpdateContractRequest} updateContractRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApiInterface
     */
    updateContractRaw(requestParameters: UpdateContractOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContractModel>>;

    /**
     * Updates a contract owned by the authorized user for the provided contractId.
     * Update contract
     */
    updateContract(requestParameters: UpdateContractOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContractModel>;

}

/**
 * 
 */
export class ContractsApi extends runtime.BaseAPI implements ContractsApiInterface {

    /**
     * Deploy a new contract from a template, or import an already deployed contract. Deploying or importing a contract through this endpoint will create a new contract object within the HYPLAY system. Once created, you can then programmatically interact with the contract gaslessly as a user, app or through a user\'s session. Use HYPLAY\'s create transaction and read contract endpoints for interactions.
     * Create contract
     */
    async createContractRaw(requestParameters: CreateContractOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContractModel>> {
        if (requestParameters['createContractRequest'] == null) {
            throw new runtime.RequiredError(
                'createContractRequest',
                'Required parameter "createContractRequest" was null or undefined when calling createContract().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xAppAuthorization'] != null) {
            headerParameters['x-app-authorization'] = String(requestParameters['xAppAuthorization']);
        }

        if (requestParameters['xAuthorization'] != null) {
            headerParameters['x-authorization'] = String(requestParameters['xAuthorization']);
        }

        const response = await this.request({
            path: `/v1/contracts`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateContractRequestToJSON(requestParameters['createContractRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ContractModelFromJSON(jsonValue));
    }

    /**
     * Deploy a new contract from a template, or import an already deployed contract. Deploying or importing a contract through this endpoint will create a new contract object within the HYPLAY system. Once created, you can then programmatically interact with the contract gaslessly as a user, app or through a user\'s session. Use HYPLAY\'s create transaction and read contract endpoints for interactions.
     * Create contract
     */
    async createContract(requestParameters: CreateContractOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContractModel> {
        const response = await this.createContractRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new template. Templates can be used to quickly deploy pre-approved types of contracts to HYCHAIN and HYCHAIN_TESTNET.
     * Create template
     */
    async createTemplateRaw(requestParameters: CreateTemplateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TemplateModel>> {
        if (requestParameters['xAuthorization'] == null) {
            throw new runtime.RequiredError(
                'xAuthorization',
                'Required parameter "xAuthorization" was null or undefined when calling createTemplate().'
            );
        }

        if (requestParameters['createTemplateRequest'] == null) {
            throw new runtime.RequiredError(
                'createTemplateRequest',
                'Required parameter "createTemplateRequest" was null or undefined when calling createTemplate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xAuthorization'] != null) {
            headerParameters['x-authorization'] = String(requestParameters['xAuthorization']);
        }

        const response = await this.request({
            path: `/v1/templates`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateTemplateRequestToJSON(requestParameters['createTemplateRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TemplateModelFromJSON(jsonValue));
    }

    /**
     * Creates a new template. Templates can be used to quickly deploy pre-approved types of contracts to HYCHAIN and HYCHAIN_TESTNET.
     * Create template
     */
    async createTemplate(requestParameters: CreateTemplateOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TemplateModel> {
        const response = await this.createTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a contract object for the provided contractId.
     * Get contract
     */
    async getContractRaw(requestParameters: GetContractRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContractModel>> {
        if (requestParameters['contractId'] == null) {
            throw new runtime.RequiredError(
                'contractId',
                'Required parameter "contractId" was null or undefined when calling getContract().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/contracts/{contractId}`.replace(`{${"contractId"}}`, encodeURIComponent(String(requestParameters['contractId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ContractModelFromJSON(jsonValue));
    }

    /**
     * Returns a contract object for the provided contractId.
     * Get contract
     */
    async getContract(requestParameters: GetContractRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContractModel> {
        const response = await this.getContractRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returned an array of contracts owned by the authorized user.
     * Get owned contracts
     */
    async getOwnedContractsRaw(requestParameters: GetOwnedContractsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ContractModel>>> {
        if (requestParameters['xAuthorization'] == null) {
            throw new runtime.RequiredError(
                'xAuthorization',
                'Required parameter "xAuthorization" was null or undefined when calling getOwnedContracts().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAuthorization'] != null) {
            headerParameters['x-authorization'] = String(requestParameters['xAuthorization']);
        }

        const response = await this.request({
            path: `/v1/contracts`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ContractModelFromJSON));
    }

    /**
     * Returned an array of contracts owned by the authorized user.
     * Get owned contracts
     */
    async getOwnedContracts(requestParameters: GetOwnedContractsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ContractModel>> {
        const response = await this.getOwnedContractsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a template object with abi, bytecode and compilation errors or warnings included.
     * Get template
     */
    async getTemplateRaw(requestParameters: GetTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TemplateModel>> {
        if (requestParameters['templateId'] == null) {
            throw new runtime.RequiredError(
                'templateId',
                'Required parameter "templateId" was null or undefined when calling getTemplate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/templates/{templateId}`.replace(`{${"templateId"}}`, encodeURIComponent(String(requestParameters['templateId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TemplateModelFromJSON(jsonValue));
    }

    /**
     * Returns a template object with abi, bytecode and compilation errors or warnings included.
     * Get template
     */
    async getTemplate(requestParameters: GetTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TemplateModel> {
        const response = await this.getTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns an array of templates. Templates can be used to quickly deploy contracts to HYCHAIN and HYCHAIN_TESTNET. Templates can also be reviewed and approved by the HYPLAY team to be made available for anyone to deploy. Templates that are not approved can be deployed by anyone to HYCHAIN_TESTNET, and only deployed by the creator to HYCHAIN mainnet.
     * Get templates
     */
    async getTemplatesRaw(requestParameters: GetTemplatesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<TemplateModel>>> {
        const queryParameters: any = {};

        if (requestParameters['userId'] != null) {
            queryParameters['userId'] = requestParameters['userId'];
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['approved'] != null) {
            queryParameters['approved'] = requestParameters['approved'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/templates`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TemplateModelFromJSON));
    }

    /**
     * Returns an array of templates. Templates can be used to quickly deploy contracts to HYCHAIN and HYCHAIN_TESTNET. Templates can also be reviewed and approved by the HYPLAY team to be made available for anyone to deploy. Templates that are not approved can be deployed by anyone to HYCHAIN_TESTNET, and only deployed by the creator to HYCHAIN mainnet.
     * Get templates
     */
    async getTemplates(requestParameters: GetTemplatesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<TemplateModel>> {
        const response = await this.getTemplatesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the value from a read function of a target contract. This endpoint is designed to be highly flexible. It can read any contract by providing a contract address for `contractIdOrAddress`. It can also read using contracts created in the HYCHAIN systems through the `POST /v1/contracts` endpoint, which will utilize the contract\'s ABI.  Additionally, reads can be performed as a HYCHAIN app, user or user\'s session provided, through header authorization, or any arbitrary address or walletId provided through the `as` query parameter. Alternatively you can omit all of this and perform a read as no specific address.  The `func` query parameter accepts a complete function signature with parameters, such as `getCount()` or `readCounter(address,uint256)`, or a known function name without parameters if a contractId was provided for `contractIdOrAddress` and the contract\'s ABI is known. Such as `readCounter`.
     * Read contract
     */
    async readContractRaw(requestParameters: ReadContractRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['contractIdOrAddress'] == null) {
            throw new runtime.RequiredError(
                'contractIdOrAddress',
                'Required parameter "contractIdOrAddress" was null or undefined when calling readContract().'
            );
        }

        if (requestParameters['func'] == null) {
            throw new runtime.RequiredError(
                'func',
                'Required parameter "func" was null or undefined when calling readContract().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['chain'] != null) {
            queryParameters['chain'] = requestParameters['chain'];
        }

        if (requestParameters['func'] != null) {
            queryParameters['func'] = requestParameters['func'];
        }

        if (requestParameters['args'] != null) {
            queryParameters['args'] = requestParameters['args'];
        }

        if (requestParameters['as'] != null) {
            queryParameters['as'] = requestParameters['as'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xAppAuthorization'] != null) {
            headerParameters['x-app-authorization'] = String(requestParameters['xAppAuthorization']);
        }

        if (requestParameters['xSessionAuthorization'] != null) {
            headerParameters['x-session-authorization'] = String(requestParameters['xSessionAuthorization']);
        }

        if (requestParameters['xAuthorization'] != null) {
            headerParameters['x-authorization'] = String(requestParameters['xAuthorization']);
        }

        const response = await this.request({
            path: `/v1/contracts/{contractIdOrAddress}/read`.replace(`{${"contractIdOrAddress"}}`, encodeURIComponent(String(requestParameters['contractIdOrAddress']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Get the value from a read function of a target contract. This endpoint is designed to be highly flexible. It can read any contract by providing a contract address for `contractIdOrAddress`. It can also read using contracts created in the HYCHAIN systems through the `POST /v1/contracts` endpoint, which will utilize the contract\'s ABI.  Additionally, reads can be performed as a HYCHAIN app, user or user\'s session provided, through header authorization, or any arbitrary address or walletId provided through the `as` query parameter. Alternatively you can omit all of this and perform a read as no specific address.  The `func` query parameter accepts a complete function signature with parameters, such as `getCount()` or `readCounter(address,uint256)`, or a known function name without parameters if a contractId was provided for `contractIdOrAddress` and the contract\'s ABI is known. Such as `readCounter`.
     * Read contract
     */
    async readContract(requestParameters: ReadContractRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.readContractRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a contract owned by the authorized user for the provided contractId.
     * Update contract
     */
    async updateContractRaw(requestParameters: UpdateContractOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContractModel>> {
        if (requestParameters['xAuthorization'] == null) {
            throw new runtime.RequiredError(
                'xAuthorization',
                'Required parameter "xAuthorization" was null or undefined when calling updateContract().'
            );
        }

        if (requestParameters['contractId'] == null) {
            throw new runtime.RequiredError(
                'contractId',
                'Required parameter "contractId" was null or undefined when calling updateContract().'
            );
        }

        if (requestParameters['updateContractRequest'] == null) {
            throw new runtime.RequiredError(
                'updateContractRequest',
                'Required parameter "updateContractRequest" was null or undefined when calling updateContract().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xAuthorization'] != null) {
            headerParameters['x-authorization'] = String(requestParameters['xAuthorization']);
        }

        const response = await this.request({
            path: `/v1/contracts/{contractId}`.replace(`{${"contractId"}}`, encodeURIComponent(String(requestParameters['contractId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateContractRequestToJSON(requestParameters['updateContractRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ContractModelFromJSON(jsonValue));
    }

    /**
     * Updates a contract owned by the authorized user for the provided contractId.
     * Update contract
     */
    async updateContract(requestParameters: UpdateContractOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContractModel> {
        const response = await this.updateContractRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const ReadContractChainEnum = {
    Hychain: 'HYCHAIN',
    HychainTestnet: 'HYCHAIN_TESTNET',
    Local: 'LOCAL'
} as const;
export type ReadContractChainEnum = typeof ReadContractChainEnum[keyof typeof ReadContractChainEnum];
